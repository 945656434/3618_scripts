# For most purposes, a simple vector is not enough, and more structure is
# needed.  We'll use more elaborate ways of storing data, ways that contain
# more information about how the data is to be structured.  The next least
# complicated structure of this is the matrix, accessed by the matrix()
# function.  Because this function is more complicated than c(), it is a good
# idea to check some of R's internal docmentation:
?matrix

# Under usage, we are told what information the matrix function needs to form
# its output.  All of the aruguments given are keyword arguments (kwargs)
# with default values given.  To form a matrix from data that we have using
# this function, we will need to know a few things: the data that we want to
# put in the matrix (this will be a numerical vector, for now), either a number
# of rows or columns to coerce the matrix to have, a decision about whether
# "yrow should be TRUE or FALSE (this determines how the vector is laid out
# in the matrix), and finally descriptive names for the row and column
# dimensions if needed.

# Specifying the number of rows or the number of columns is enough to determine
# the matrix, so you need not specify both (and you should not do it either,
# unless you have a good reason).  Look at what happens if try to attach  and 
# extra specification:
x <- c(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
M_1 <- matrix(x, nrow=2)
M_1
M_2 <- matrix(x, ncol=2)
M_2
M_3 <- matrix(x, ncol=2, nrow=2)
M_3
M_4 <- matrix(x, nrow=2, ncol=2)
M_4

# Exercise: repeat all of these constructions, adding byrow=TRUE to the list of
# arguments.

# dimnames is supposed to be a vector of names of length 2, such as
# (row_names, col_names).  What isn't obvious is that each of these should
# itself be a list of character strings.  Let's make a matrix with names given
# for its rows and columns:
rownames = c("monkey", "tiger")
colnames = c("height", "weight")
dimnames = list(rownames, colnames)
A <- matrix(c(2, 3, 60, 620), nrow=2, dimnames=dimnames)
A

# Exercise: I used a new function, list(), to compile the list of names here.
# What would have happened if I had used c() instead?

# Exercise: When I wrote "dimnames=dimnames" as an argument for the matrix
# function, what was a trying to tell the matrix function to do?  Answer this 
# again after doing the next exercise!

# Now that we've named the rows and columns, let's practice grabbing pieces
# of the matrix.  We can do this using entry indices or names:
A["monkey", "weight"]
A[1, 2]

# In mathmatics, we would normally use the indices to label entries, but
# it's often more intuitive to use descriptive names when refering to
# real-life data.  It may also be required if the data is being pulled from
# an outside database, so this labeling scheme can be vital!

# Exercise. For the matrix B generated by the code below, determine what
# happens when you do the following:
#  -leave a space in place of one of your indices or names
#  -give a vector of indices or labels instead of just a single index
#  -give just a single number instead of a pair
#  -give just a single name instead of a pair of names
B_rownames = c("A", "B", "C", "D", "E")
B_colnames = c("Red", "Orange", "Yellow", "Green", "Blue")
B_dimnames = list(B_rownames, B_colnames)
B = matrix(1:25, nrow=5, dimnames=B_dimnames)
B

# Exercise.  Try out all of the vector and scalar arithmetic that we did
# before, but on matrices.  Start with B + B[1, ].  What do these operations
# tend to do?

# Exercise. Try out the following functions on B: rowSums(), colSums(),
# sum(), and the same functions with "sum" replaced by "mean".  What happens?